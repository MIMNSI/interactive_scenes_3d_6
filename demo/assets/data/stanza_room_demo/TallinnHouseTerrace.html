
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Stanza Tallinn House | Terrace</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    /* Your existing CSS styles */
    body, html { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; font-family: Arial, sans-serif; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; }
  
    #hotspotContent {
      position: fixed;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 10px;
      z-index: 1001;
      max-width: 300px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      display: none;
      font-size: 14px;
    }
    #infoPopup {
      position: absolute;
      bottom: 35px;
      left: 10%;
      background-color: rgba(0,0,0,0.7);
      color: white;
      border: none;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 1000;
    }
    #scrollControls {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* Option picker like quickview */
    .option-picker {
      margin-bottom: 10px;
      left: 50px;
      justify-content: space-around;
      align-items: center;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.8); /* Frosty black glass effect */
      backdrop-filter: blur(5px);
      border-radius: 5px;
    }

    .option-button {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background-color: #90EE90; /* Light green */
      color: #333;
      font-weight: bold;
    }

    .option-button.active {
      background-color: #006400; /* Dark green */
      color: #fff;
    }

    #toggleCameraModeContainer {
      margin-bottom: 10px;
    }

    #scrollControlsContent,
    #exploreControlsContent {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.3s ease-in-out;
      width: 100%;
    }

    #scrollControlsContent.hidden,
    #exploreControlsContent.hidden {
      opacity: 0;
      pointer-events: none;
      position: absolute;
    }

    #exploreControlsContent p {
      color: white;
      font-size: 14px;
      text-align: center;
      margin: 0;
    }
    
    #scrollControls {
      position: absolute;
      bottom: 20px;
      left: 10%;
      transform: translateX(-50%);
      background-color: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      color: white;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    #scrollPercentage {
      font-size: 18px;
      margin-bottom: 10px;
    }
    #progressBarContainer {
      width: 200px;
      height: 10px;
      background-color: rgba(255,255,255,0.3);
      border-radius: 5px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background-color: #4CAF50;
      transition: width 0.3s ease;
    }
    .button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    .button:hover {
       background-color: #197c1d;
    }
    #scrollButtons {
      display: flex;
      justify-content: space-between;
      width: 100%;
    }
    
    #muteButton {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0,0,0,0.7);
      color: white;
      border: none;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 1000;
    }

    #preloader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #1e1e1e;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100000;
      transition: opacity 0.5s ease-out;
    }

    #preloader.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #preloader h1 {
      font-size: 48px;
      color: #ffffff;
      text-align: center;
      font-family: 'DM Sans', sans-serif;
    }

    #preloader .spinner {
      width: 25px;
      height: 25px;
      border: 5px solid #ffffff;
      border-top: 5px solid #F76900;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Start Screen Frosted Glass Effect */
    #startButtonContainer {
      position: absolute; 
      width: 100%; 
      height: 100%; 
      background-color: rgba(255, 255, 255, 0.2); 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      z-index: 10000; 
      backdrop-filter: blur(10px); 
      -webkit-backdrop-filter: blur(10px);
    }
    #startButton {
      padding: 20px 40px; 
      font-size: 24px; 
      background-color: rgba(255, 255, 255, 0.25); 
      color: white; 
      border: none; 
      border-radius: 5px; 
      cursor: pointer;
    }
    

    /* Ensure the toggleCameraMode button has consistent styling */
    #toggleCameraMode {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    #toggleCameraMode:hover {
       background-color: #197c1d;
    }

    /* Joystick Styles */
    #joystickContainer {
      position: absolute;
      bottom: 50px;
      left: 50px;
      z-index: 1000;
    }
    #joystickCanvas {
      width: 100px;
      height: 100px;
      touch-action: none;
    }

  </style>
</head>
<body>
  <div id="preloader">
    <h1>MetaShop AI</h1>
    <div class="spinner"></div>
  </div>
  <!-- Start Screen -->
  <div id="startButtonContainer">
    <button id="startButton">Start Experience</button>
  </div>
  <canvas id="renderCanvas"></canvas>
  <!-- Movement Instructions -->
  
  <!-- Hotspot and Info Popup -->
  <div id="hotspotContent"></div>
  <div id="infoPopup"></div>
  <!-- Scroll Controls -->
  
  <!--<div id="scrollControls">
   
        <div id="toggleCameraModeContainer">
      <button id="toggleCameraMode" onclick="toggleCameraMode()">Mode: Auto</button>
    </div>
    <div id="scrollControlsContent">
      <div id="scrollPercentage">0%</div>
      <div id="progressBarContainer">
        <div id="progressBar"></div>
      </div>
      <div class="option-picker">
        <button class="option-button active">Flythrough</button>
        <button class="option-button">Explore</button>
      </div>
      <div id="scrollButtons">
        <button class="button" onclick="handleButtonScroll(-1)">â—€ Prev</button>
        <button class="button" onclick="handleButtonScroll(1)">Next â–¶</button>
      </div>
    </div>
    <div id="exploreControlsContent">
      <p>Use WASD to move and mouse to look around</p>
    </div>
  </div>-->
  
  <!-- Mute Button -->
  <button id="muteButton">ðŸ”Š Mute</button>

  <!-- Babylon.js CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script>
    // Initialize cameraMode and other variables
    let cameraMode = 'tour';
    const allowedCameraModes = ["tour"];
    let loopMode = true;
    let autoPlaySpeed = 0.21;
    let autoPlayEnabled = true;

    

    const preloader = document.getElementById('preloader');
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    window.scene = scene;

    // Set the background color
    scene.clearColor = BABYLON.Color3.FromHexString('#7D7D7D').toColor4(1);

    // Create the camera
    const camera = new BABYLON.UniversalCamera(
      'camera',
      new BABYLON.Vector3(21.443951459895377, -8.265889256556655, -2.948045660291122),
      scene
    );
    camera.attachControl(canvas, true);

    // Adjust camera sensitivity
    camera.speed = 0.5;
    camera.angularSensibility = 4000;

    // Initialize rotationQuaternion with the first waypoint's rotation
    camera.rotationQuaternion = new BABYLON.Quaternion(
      -0.02817488167130738,
      0.9382702036129691,
      -0.07876282165946379,
      -0.33563614075234005
    ).normalize();

    // Ensure Euler angles match the quaternion
    camera.rotation = camera.rotationQuaternion.toEulerAngles();

    // Enable WASD keys for movement
    camera.keysUp.push(87); // W
    camera.keysDown.push(83); // S
    camera.keysLeft.push(65); // A
    camera.keysRight.push(68); // D

    // Add Q and E keys for vertical movement
    camera.keysUpward.push(81); // Q
    camera.keysDownward.push(69); // E
    camera.inputs.addGamepad();

    // Variables to manage camera control state
    let userControl = cameraMode === 'explore';
    let animatingToPath = false;

    const isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(
      navigator.userAgent.toLowerCase()
    );

    if (isMobileDevice) {
      var leftJoystick = new BABYLON.VirtualJoystick(true);
      var rightJoystick = new BABYLON.VirtualJoystick(false);
      if('tour' === 'tour'){
      if(BABYLON.VirtualJoystick.Canvas){
          BABYLON.VirtualJoystick.Canvas.style.zIndex = "-10";
  }} else {
         if(BABYLON.VirtualJoystick.Canvas){
          BABYLON.VirtualJoystick.Canvas.style.zIndex = "10";
  }
  }
  
      scene.onBeforeRenderObservable.add(()=>{
          if(leftJoystick.pressed){
            userControl = true;
            const deltaTime = engine.getDeltaTime() / 1000;
            const moveSpeed = deltaTime * 5 * 0.5;
        
            // Get the movement values from the joystick
            const moveX = leftJoystick.deltaPosition.x * moveSpeed;
            const moveZ = leftJoystick.deltaPosition.y * moveSpeed;
        
            // Calculate the forward and right directions
            const forward = camera.getDirection(BABYLON.Axis.Z);
            const right = camera.getDirection(BABYLON.Axis.X);
        
            // Calculate the movement vector
            const move = forward.scale(moveZ).add(right.scale(moveX));
        
            // Update the camera position
            camera.position.addInPlace(move);
              
          }
          if (rightJoystick.pressed) {
            const deltaX = rightJoystick.deltaPosition.x;
            const deltaY = rightJoystick.deltaPosition.y;
        
            const angularSensibility = 200 * 0.5; // Adjust rotation speed
        
            // Get current yaw and pitch from the camera's rotation quaternion
            const currentEuler = camera.rotationQuaternion.toEulerAngles();
            let yaw = currentEuler.y;
            let pitch = currentEuler.x;
        
            // Update yaw and pitch based on joystick input
            yaw += deltaX / angularSensibility;
            pitch -= deltaY / angularSensibility;
        
            // Clamp the pitch to prevent rolling
            const maxPitch = Math.PI / 2; // Maximum pitch angle (90 degrees)
            pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
        
            // Update the camera's rotation quaternion without introducing roll
            camera.rotationQuaternion = BABYLON.Quaternion.RotationYawPitchRoll(yaw, pitch, 0);
        }
      })
    }
    // Enable camera collisions and gravity
    camera.checkCollisions = true;
    camera.applyGravity = false;
    camera.ellipsoid = new BABYLON.Vector3(0.1, 0.1, 0.1);

    // Create a basic light
    new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);


    // Variables for scroll position and target
    let scrollPosition = 0;
    let scrollTarget = 0.01; // Start with a small value to enable scrolling

    // Prepare waypoints and rotations
    const waypoints = [{"x":21.443951459895377,"y":-8.265889256556655,"z":-2.948045660291122,"rotation":{"_isDirty":true,"_x":-0.02817488167130738,"_y":0.9382702036129691,"_z":-0.07876282165946379,"_w":-0.33563614075234005},"interactions":[],"triggerDistance":1},{"x":19.34216218596245,"y":-7.6122247712034135,"z":-7.337355737855361,"rotation":{"_isDirty":true,"_x":-0.0037876561041055665,"_y":0.9856148978915347,"_z":-0.022289229522606365,"_w":-0.167487662121082},"interactions":[],"triggerDistance":1},{"x":18.545072366568117,"y":-7.822809963390994,"z":-13.938466297006853,"rotation":{"_isDirty":true,"_x":0.02416217581459185,"_y":-0.742004913915546,"_z":0.026781935840229483,"_w":0.6694233525189706},"interactions":[],"triggerDistance":1},{"x":15.698750570098861,"y":-7.792904815047819,"z":-18.76282853600129,"rotation":{"_isDirty":true,"_x":0.015613614094632551,"_y":-0.2288079784245183,"_z":0.0036703742597264384,"_w":0.9733394333001116},"interactions":[],"triggerDistance":null},{"x":10.534173201237904,"y":-7.82110748104975,"z":-7.862000188936026,"rotation":{"_isDirty":true,"_x":0.03737455687528205,"_y":-0.17730764574043412,"_z":0.006738503902361013,"_w":0.9834224594880466},"interactions":[{"id":"interaction-1731036227617","type":"info","data":{"text":"Cooking Area with Refrigerator and Microwave Oven"}}],"triggerDistance":2},{"x":12.74396791378728,"y":-7.8959302299238265,"z":-4.341006481234035,"rotation":{"_isDirty":true,"_x":0.049875188967097535,"_y":-0.34484997434011055,"_z":0.01835289641542174,"_w":0.9371521391515288},"interactions":[],"triggerDistance":2},{"x":10.424297616293856,"y":-8.393582741338989,"z":-4.691159192231478,"rotation":{"_isDirty":true,"_x":0.031072345212691217,"_y":-0.1476153950522059,"_z":0.004639903434832042,"_w":0.988545737840531},"interactions":[],"triggerDistance":1},{"x":6.404956043232622,"y":-7.8893963245411864,"z":-6.4296214414659305,"rotation":{"_isDirty":true,"_x":0.02192579079364579,"_y":0.7048456409845905,"_z":-0.021806963313220084,"_w":0.7086863470070177},"interactions":[],"triggerDistance":1},{"x":14.904592215343985,"y":-6.849383329483896,"z":-4.217244884061406,"rotation":{"_isDirty":true,"_x":0.10253531057722533,"_y":0.8606882750223552,"_z":-0.19168780392607132,"_w":0.46038895420054826},"interactions":[{"id":"interaction-1731035683856","type":"info","data":{"text":"Game Area 1"}}],"triggerDistance":2},{"x":16.280177760326364,"y":-7.010566218312659,"z":-4.064861385175063,"rotation":{"_isDirty":true,"_x":0.10761848239733018,"_y":0.8753677892314063,"_z":-0.22853565922561556,"_w":0.4122146871290847},"interactions":[{"id":"interaction-1731035738239","type":"info","data":{"text":"Game Area 1"}}],"triggerDistance":2},{"x":21.250542375423194,"y":-8.147101766356664,"z":-4.09909384018709,"rotation":{"_isDirty":true,"_x":-0.05461257803445825,"_y":0.9453754806002941,"_z":-0.2247904538577313,"_w":-0.22967785886895647},"interactions":[{"id":"interaction-1731035762156","type":"info","data":{"text":"Game Area 1"}}],"triggerDistance":3},{"x":14.145198798907055,"y":-7.724953813803871,"z":-14.959399408755468,"rotation":{"_isDirty":true,"_x":-0.06269514164199927,"_y":0.9347498972003547,"_z":-0.2804231566303076,"_w":-0.20898517201923703},"interactions":[],"triggerDistance":1},{"x":15.851865202742255,"y":-7.724953813751674,"z":-16.537068366655728,"rotation":{"_isDirty":true,"_x":0.16162420259019358,"_y":-0.7990407153417514,"_z":0.24640467358787185,"_w":0.5241147672001627},"interactions":[{"id":"interaction-1731035834709","type":"info","data":{"text":"Game Area 2"}}],"triggerDistance":3},{"x":9.68464098818471,"y":-7.724953814398527,"z":-15.233494637433157,"rotation":{"_isDirty":true,"_x":0.12638511654780804,"_y":0.8565558548571702,"_z":-0.24967172541694274,"_w":0.4335930111895556},"interactions":[{"id":"interaction-1731035804357","type":"info","data":{"text":"Game Area 2"}}],"triggerDistance":3},{"x":9.426737846980414,"y":-7.797324894800942,"z":-12.303239667331905,"rotation":{"_isDirty":true,"_x":0.005416684736113975,"_y":0.9911960946956021,"_z":-0.12514088366006854,"_w":0.04290362016699602},"interactions":[],"triggerDistance":1},{"x":7.720897224027344,"y":-7.797324894029192,"z":-12.679694380961124,"rotation":{"_isDirty":true,"_x":0.02726011287559199,"_y":0.9663426814244921,"_z":-0.11538015775014818,"_w":0.22831147036643504},"interactions":[],"triggerDistance":1},{"x":12.558297285823649,"y":-7.499317869248225,"z":-14.155162514018258,"rotation":{"_isDirty":true,"_x":-0.06479299205855756,"_y":0.8704574463349144,"_z":-0.11919273009142381,"_w":-0.4731794536891392},"interactions":[],"triggerDistance":1},{"x":10.496216899772904,"y":-7.653281930921564,"z":-15.261585062105974,"rotation":{"_isDirty":true,"_x":0.14018653316260596,"_y":0.6120656677395538,"_z":-0.11139398107166558,"_w":0.770269261541306},"interactions":[],"triggerDistance":1},{"x":11.661318824655819,"y":-8.14661496810616,"z":-10.237735019799388,"rotation":{"_isDirty":true,"_x":0.06383374964384626,"_y":0.8954199464893513,"_z":-0.13642477928450253,"_w":0.41897094342279745},"interactions":[],"triggerDistance":1}];
    const controlPoints = waypoints.map(
      (wp) => new BABYLON.Vector3(wp.x, wp.y, wp.z)
    );
    const rotations = waypoints.map(
      (wp) => new BABYLON.Quaternion(wp.rotation._x, wp.rotation._y, wp.rotation._z, wp.rotation._w).normalize()
    );

    let path = [];

    if (controlPoints.length >= 2) {
      const positionCurve = BABYLON.Curve3.CreateCatmullRomSpline(
        controlPoints,
        20, // Adjust resolution if needed
        false //loopMode
      );
      path = positionCurve.getPoints();
    } else if (controlPoints.length === 1) {
      path = [controlPoints[0]];
    }

    // Create hotspots
    const hotspots = [];

    hotspots.forEach(hotspot => {
      const scale = (hotspot.scale._x === 0 && hotspot.scale._y === 0 && hotspot.scale._z === 0)
        ? new BABYLON.Vector3(1, 1, 1) 
        : new BABYLON.Vector3(hotspot.scale._x, hotspot.scale._y, hotspot.scale._z);

      const sphere = BABYLON.MeshBuilder.CreateSphere(`hotspot-${hotspot.id}`, { diameter: 0.2 }, scene);
      sphere.position = new BABYLON.Vector3(hotspot.position._x, hotspot.position._y, hotspot.position._z);
      sphere.scaling = scale;
      
      const material = new BABYLON.StandardMaterial(`hotspot-material-${hotspot.id}`, scene);
      material.diffuseColor = BABYLON.Color3.FromHexString(hotspot.color);
      material.emissiveColor = BABYLON.Color3.FromHexString(hotspot.color).scale(0.5);
      sphere.material = material;

      sphere.isPickable = true;

      sphere.actionManager = new BABYLON.ActionManager(scene);
      sphere.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(
          BABYLON.ActionManager.OnPointerOverTrigger,
          () => {
            material.emissiveColor = BABYLON.Color3.FromHexString(hotspot.color);
            if (hotspot.activationMode === 'hover') {
              showHotspotContent(hotspot);
            }
          }
        )
      );
      sphere.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(
          BABYLON.ActionManager.OnPointerOutTrigger,
          () => {
            material.emissiveColor = BABYLON.Color3.FromHexString(hotspot.color).scale(0.5);
            if (hotspot.activationMode === 'hover') {
              hideHotspotContent();
            }
          }
        )
      );
      if (hotspot.activationMode === 'click') {
        sphere.actionManager.registerAction(
          new BABYLON.ExecuteCodeAction(
            BABYLON.ActionManager.OnPickTrigger,
            () => {
              showHotspotContent(hotspot);
            }
          )
        );
      }
    });

    // Function to show hotspot content
    function showHotspotContent(hotspot) {
      const hotspotContent = document.getElementById('hotspotContent');
      hotspotContent.innerHTML = `
        <h3>${hotspot.title}</h3>
        ${hotspot.photoUrl ? `<img src="${hotspot.photoUrl}" alt="${hotspot.title}" style="width: 100%; margin-bottom: 10px; border-radius: 5px;">` : ''}
        ${hotspot.information ? `<p>${hotspot.information}</p>` : ''}
        ${hotspot.activationMode === 'click' ? '<button onclick="hideHotspotContent()" style="width: 100%; padding: 10px; background-color: #4CAF50; border: none; color: white; cursor: pointer; border-radius: 5px;">Close</button>' : ''}
      `;
      hotspotContent.style.display = 'block';
      positionHotspotContent(hotspotContent);
    }

    // Function to hide hotspot content
    function hideHotspotContent() {
      const hotspotContent = document.getElementById('hotspotContent');
      hotspotContent.style.display = 'none';
    }

    // Function to position hotspot content near the mouse
    function positionHotspotContent(element) {
      const rect = element.getBoundingClientRect();
      let left = scene.pointerX + 10;
      let top = scene.pointerY + 10;

      if (left + rect.width > window.innerWidth) {
        left = window.innerWidth - rect.width - 10;
      }
      if (top + rect.height > window.innerHeight) {
        top = window.innerHeight - rect.height - 10;
      }

      element.style.left = `${left}px`;
      element.style.top = `${top}px`;
    }

    // Collision Meshes Data
    const collisionMeshesData = [];

    // Function to reconstruct collision meshes
    function createCollisionMeshes() {
      collisionMeshesData.forEach((data, index) => {
        const mesh = BABYLON.MeshBuilder.CreatePlane(
          `collisionMesh-${index}`,
          { size: 3 },
          scene
        );
        mesh.position = new BABYLON.Vector3(
          data.position._x,
          data.position._y,
          data.position._z
        );
        mesh.rotation = new BABYLON.Vector3(
          data.rotation._x,
          data.rotation._y,
          data.rotation._z
        );
        mesh.scaling = new BABYLON.Vector3(
          data.scaling._x,
          data.scaling._y,
          data.scaling._z
        );
        mesh.checkCollisions = true;
        mesh.isVisible = false; // Hide collision meshes

        // Optional: Apply material if you want to visualize the collision meshes
        /*
        const material = new BABYLON.StandardMaterial(
          `collisionMaterial-${index}`,
          scene
        );
        material.backFaceCulling = false;
        material.diffuseColor = BABYLON.Color3.FromHexString("#FF0000");
        mesh.material = material;
        */
      });
    }

    // Call the function to create collision meshes
    createCollisionMeshes();

    // Mute state
    let isMuted = false;
    const activeSounds = {};

    // Updated playAudio function
    function playAudio(interactionData, waypointIndex) {
      if (isMuted) return;

      const id = interactionData.id;
      const url = interactionData.url;
      const data = interactionData;

      // If sound is already playing, do not play it again
      if (activeSounds[id] && activeSounds[id].isPlaying) {
        return;
      }

      if (activeSounds[id]) {
        // Sound object already exists, play it if not playing
        if (!activeSounds[id].isPlaying) {
          activeSounds[id].play();
        }
      } else {
        // Create new sound
        const sound = new BABYLON.Sound(
          id,
          url,
          scene,
          () => {
            // Play the sound once it's ready
            sound.play();
          },
          {
            loop: data.loop !== undefined ? data.loop : true,
            volume: data.volume !== undefined ? data.volume : 1,
            spatialSound: data.spatialSound !== undefined ? data.spatialSound : false,
            distanceModel: data.distanceModel !== undefined ? data.distanceModel : "exponential",
            maxDistance: data.maxDistance !== undefined ? data.maxDistance : 100,
            refDistance: data.refDistance !== undefined ? data.refDistance : 1,
            rolloffFactor: data.rolloffFactor !== undefined ? data.rolloffFactor : 1,
          }
        );

        activeSounds[id] = sound;

        if (data.spatialSound) {
          let position;
          if (waypointIndex !== undefined && waypoints[waypointIndex]) {
            const waypoint = waypoints[waypointIndex];
            position = new BABYLON.Vector3(waypoint.x, waypoint.y, waypoint.z);
          } else {
            position = new BABYLON.Vector3(0, 0, 0); // Default position if waypoint is undefined
          }

          sound.setPosition(position);
        }
      }
    }

    // Updated stopAudio function
    function stopAudio(interactionData) {
      const id = interactionData.id;
      const sound = activeSounds[id];
      if (sound && sound.isPlaying) {
        sound.stop();
      }
      // Remove the sound from activeSounds to clean up
      delete activeSounds[id];
    }

    // Function to execute interactions
    const executeInteractions = (interactions, waypointIndex) => {
      interactions.forEach((interaction) => {
        switch (interaction.type) {
          case "audio":
            playAudio({ ...interaction.data, id: interaction.id }, waypointIndex);
            break;
          case "info":
            showInfoPopup(interaction.data.text);
            break;
          // Add other interaction types here if needed
        }
      });
    };

    // Function to reverse interactions
    const reverseInteractions = (interactions) => {
      interactions.forEach((interaction) => {
        switch (interaction.type) {
          case "audio":
            const data = interaction.data;
            if (!data.spatialSound && data.stopOnExit) {
              stopAudio({ ...data, id: interaction.id });
            }
            break;
          case "info":
            hideInfoPopup();
            break;
          // Add other interaction types here if needed
        }
      });
    };

    let transitionSpeed = 0.52;

    function updateTransitionSpeed(value) {
      transitionSpeed = parseFloat(value);
      document.getElementById('transitionSpeedValue').textContent = 'Transition Speed: ' + transitionSpeed.toFixed(1);
    }

    // Function to show info popup
    function showInfoPopup(text) {
   const infoPopup = document.getElementById('infoPopup');
      infoPopup.innerHTML = `
        <p>${text}</p>
      `;
      infoPopup.style.display = 'block';
    }

    // Function to hide info popup
    function hideInfoPopup() {
      const infoPopup = document.getElementById('infoPopup');
      infoPopup.style.display = 'none';
    }

    // Function to update scroll percentage and progress bar
    function updateScrollUI(percentage) {
        const scrollPercentage = document.getElementById('scrollPercentage');
      const progressBar = document.getElementById('progressBar');
      if (scrollPercentage && progressBar) {
        scrollPercentage.textContent = `${Math.round(percentage)}%`;
        progressBar.style.width = `${percentage}%`;
      }
    }

    const scrollButtonMode = 'waypoint';
    const scrollAmount = 10;

    function handleButtonScroll(direction) {
      if (cameraMode === 'explore') {
        return;
      }
      if (scrollButtonMode === 'percentage') {
        adjustScroll(direction * scrollAmount / 100);
      } else {
        moveToWaypoint(direction);
      }
    }

    function adjustScroll(amount) {
      const pathLength = path.length;
      if (pathLength > 1) {
        const scrollIncrement = (pathLength - 1) * amount;
        scrollTarget += scrollIncrement;

          if (scrollTarget < 0) scrollTarget = 0;
          if (scrollTarget > path.length - 1) scrollTarget = path.length - 1;

        userControl = false;
      }
    }

    function moveToWaypoint(direction) {
        const subdivisionsPerSegment = 20;
      let currentWaypointIndex = Math.round(scrollPosition / subdivisionsPerSegment);
      let nextWaypointIndex = currentWaypointIndex + direction;

        nextWaypointIndex = Math.max(0, Math.min(nextWaypointIndex, waypoints.length - 1));

      scrollTarget = nextWaypointIndex * subdivisionsPerSegment;
      userControl = false;
    }
    // Handle scroll events
    window.addEventListener('wheel', (event) => {
        if (animatingToPath) return;

      if (
        (cameraMode === 'auto' && userControl) ||
        (cameraMode === 'tour' && userControl)
      ) {
        animatingToPath = true;
        userControl = false;

        if (!camera.rotationQuaternion) {
          camera.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(
            camera.rotation.x,
            camera.rotation.y,
            camera.rotation.z
          ).normalize();
          camera.rotation.set(0, 0, 0);
        }

        // Use current scroll position instead of finding closest point
        const targetT = scrollPosition;
        const pathLength = path.length - 1;

        const floorIndex = Math.floor(targetT);
        const ceilIndex = Math.min(floorIndex + 1, pathLength);
        const lerpFactor = targetT - floorIndex;

        const targetPosition = BABYLON.Vector3.Lerp(
          path[floorIndex],
          path[ceilIndex],
          lerpFactor
        );

        let targetRotation = camera.rotationQuaternion.clone();
        if (rotations.length >= 2 && path.length >= 2) {
          const totalSegments = waypoints.length - 1;
          const segmentT = (targetT / pathLength) * totalSegments;
          const segmentIndex = Math.floor(segmentT);
          const clampedSegmentIndex = Math.min(segmentIndex, totalSegments - 1);
          const lerpFactorRot = segmentT - clampedSegmentIndex;

          const r1 = rotations[clampedSegmentIndex];
          const nextIndex = (clampedSegmentIndex + 1) % rotations.length;
          const r2 = rotations[nextIndex];
          targetRotation = BABYLON.Quaternion.Slerp(r1, r2, lerpFactorRot).normalize();
        } else if (rotations.length === 1) {
          targetRotation = rotations[0];
        }

        const positionAnimation = new BABYLON.Animation(
          'cameraPositionAnimation',
          'position',
          60,
          BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
          BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );

        const positionKeys = [];
        positionKeys.push({ frame: 0, value: camera.position.clone() });
        positionKeys.push({ frame: 120, value: targetPosition.clone() });

        positionAnimation.setKeys(positionKeys);

        const easingFunction = new BABYLON.CubicEase();
        easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
        positionAnimation.setEasingFunction(easingFunction);

        const rotationAnimation = new BABYLON.Animation(
          'cameraRotationAnimation',
          'rotationQuaternion',
          60,
          BABYLON.Animation.ANIMATIONTYPE_QUATERNION,
          BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );

        const currentRotation = camera.rotationQuaternion.clone();
        rotationAnimation.setKeys([
          { frame: 0, value: currentRotation },
          { frame: 120, value: targetRotation },
        ]);

        rotationAnimation.setEasingFunction(easingFunction);

        camera.animations = [];
        camera.animations.push(positionAnimation);
        camera.animations.push(rotationAnimation);

        scene.beginAnimation(camera, 0, 120, false, 1, function () {
          animatingToPath = false;
          scrollPosition = targetT;
          scrollTarget = targetT;
        });
      } else if (cameraMode !== 'explore') {
        scrollTarget += event.deltaY * 0.1;
          if (scrollTarget < 0) scrollTarget = 0;
          if (scrollTarget > path.length - 1) scrollTarget = path.length - 1;
      }
    });

    // Initialize target rotation and position
    let targetRotation = camera.rotationQuaternion.clone();
    let targetPosition = camera.position.clone();

    // Active waypoints set
    const activeWaypoints = new Set();
    if(false) {
    // Create floor mesh at y = 0 and hide it
    const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 100, height: 100 }, scene);    
    ground.isVisible = false;

   // WebXR setup
   const xr = scene.createDefaultXRExperienceAsync({
        floorMeshes: [ground],
     });
     }
    // Load the model file
    BABYLON.SceneLoader.ImportMeshAsync('', '', 'https://mimnsi.github.io/interactive_scenes_3d_6/demo/assets/data/stanza_room_demo/StanzaTerrace.splat', scene)
      .then((result) => {
        const loadedMeshes = result.meshes;
        loadedMeshes.forEach((mesh) => {
          if (mesh instanceof BABYLON.Mesh) {
            mesh.position = BABYLON.Vector3.Zero();
          }
        });
        // Hide the preloader after the model is loaded
        preloader.classList.add('hidden');
      })
      .catch((error) => {
        console.error('Error loading model file:', error);
        alert('Error loading model file: ' + error.message);
        preloader.classList.add('hidden');
      });

    // Start the render loop
    engine.runRenderLoop(function () {
      // Smoothly interpolate scrollPosition towards scrollTarget
      const scrollInterpolationSpeed = 0.01 + transitionSpeed * 0.1;
      // Autoplay handling
      if (autoPlayEnabled && !userControl) {
        scrollTarget += autoPlaySpeed;
      }
      scrollPosition += (scrollTarget - scrollPosition) * scrollInterpolationSpeed;

      if (loopMode) {
        if (scrollPosition >= path.length - 1.1) {
          scrollPosition = 0.2;
          scrollTarget = 0.2;
        } else if (scrollPosition <= 0.1) {
          scrollPosition = path.length - 1.11;
          scrollTarget = path.length - 1.11;
        }
      }

      // Clamp scroll position
      scrollPosition = Math.max(0, Math.min(scrollPosition, path.length - 1));    

      // Calculate scroll percentage
      const scrollPercentage = (scrollPosition / (path.length - 1 || 1)) * 100;

      // Update UI only if not in explore mode
      if (cameraMode !== 'explore') {
        updateScrollUI(scrollPercentage);
      }

      // Determine if camera should follow the path
      if (
        (cameraMode === 'auto' && !userControl) ||
        (cameraMode === 'tour' && !userControl)
      ) {
        const t = scrollPosition / (path.length - 1 || 1);

        const totalSegments = waypoints.length - 1;
        if (totalSegments >= 1) {
          const segmentT = t * totalSegments;
          const segmentIndex = Math.floor(segmentT);
          const clampedSegmentIndex = Math.min(segmentIndex, totalSegments - 1);
          const lerpFactor = segmentT - clampedSegmentIndex;

          // Calculate target rotation using Slerp
          const r1 = rotations[clampedSegmentIndex];
          const nextIndex = (clampedSegmentIndex + 1) % rotations.length;
          const r2 = rotations[nextIndex];

          targetRotation = BABYLON.Quaternion.Slerp(r1, r2, lerpFactor).normalize();

          // Calculate interpolated position using Lerp
          const floorIndex = Math.floor(scrollPosition);
          const ceilIndex = Math.min(floorIndex + 1, path.length - 1);
          const lerpFactorPos = scrollPosition - floorIndex;

          const interpolatedPosition = BABYLON.Vector3.Lerp(
            path[floorIndex],
            path[ceilIndex],
            lerpFactorPos
          );

          targetPosition = interpolatedPosition;
        } else if (rotations.length === 1) {
          targetRotation = rotations[0].clone();
          targetPosition = path[0].clone();
        }

        // Smoothly interpolate the camera's rotation towards the target rotation
        if (camera.rotationQuaternion) {
          camera.rotationQuaternion = BABYLON.Quaternion.Slerp(
            camera.rotationQuaternion,
            targetRotation,
            0.050000000000000044 // Damping factor for rotation
          ).normalize();
        }

        // Smoothly interpolate the camera's position towards the target position
        const positionDampingFactor = 0.1; // Adjust between 0 (no movement) and 1 (instant movement)
        camera.position = BABYLON.Vector3.Lerp(
          camera.position,
          targetPosition,
          positionDampingFactor
        );

        // Handle interactions based on waypoints
        waypoints.forEach((wp, index) => {
          const distance = BABYLON.Vector3.Distance(
            camera.position,
            new BABYLON.Vector3(wp.x, wp.y, wp.z)
          );
          const triggerDistance = wp.triggerDistance ?? 1.0;

          if (distance <= triggerDistance) {
            if (!activeWaypoints.has(index)) {
              activeWaypoints.add(index);
              executeInteractions(wp.interactions, index);
            }
          } else {
            if (activeWaypoints.has(index)) {
              activeWaypoints.delete(index);
              reverseInteractions(wp.interactions);
            }
          }
        });
      }

      scene.render();
    });

    // User interaction detection
    scene.onPointerObservable.add(function (evt) {
      if (evt.type === BABYLON.PointerEventTypes.POINTERDOWN) {
        if (cameraMode === 'explore' || cameraMode === 'auto') {
          userControl = true;
        } else {
          userControl = false;
        }
      }
    });

    window.addEventListener('keydown', function () {
      if (cameraMode === 'explore' || cameraMode === 'auto') {
        userControl = true;
      } else {
        userControl = false;
      }
    });

    // Mute button functionality
    const muteButton = document.getElementById('muteButton');
    muteButton.textContent = isMuted ? 'ðŸ”‡ Unmute' : 'ðŸ”Š Mute';
    muteButton.addEventListener('click', function() {
      isMuted = !isMuted;
      muteButton.textContent = isMuted ? 'ðŸ”‡ Unmute' : 'ðŸ”Š Mute';

      if (isMuted) {
        // Stop all active sounds
        Object.values(activeSounds).forEach(sound => {
          if (sound.isPlaying) {
            sound.pause();
          }
        });
      } else {
        // Resume sounds that should be playing
        Object.values(activeSounds).forEach(sound => {
          if (!sound.isPlaying) {
            sound.play();
          }
        });
      }
    });

    // Start button functionality
    document.getElementById('startButton').addEventListener('click', function() {
      // Hide the start button
      document.getElementById('startButtonContainer').style.display = 'none';

      // Resume audio context if suspended
      if (BABYLON.Engine.audioEngine.audioContext.state === 'suspended') {
        BABYLON.Engine.audioEngine.audioContext.resume();
      }

      // Play audio interactions with autoplay set to true
      waypoints.forEach((wp, index) => {
        wp.interactions.forEach((interaction) => {
          if (interaction.type === 'audio') {
            const data = interaction.data;
            if (data.autoplay) {
              playAudio({ ...data, id: interaction.id }, index);
            }
          }
        });
      });
    });

    // Resize
    window.addEventListener('resize', function () {
      engine.resize();
    });

  </script>
</body>
</html>
  